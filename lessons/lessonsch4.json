{
  "lesson": [
    {
      "title": "Removing Files",
      "body": "<p>To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit. The git rm command does that, and also removes the file from your working directory so you don’t see it as an untracked file the next time around. </p><p> If you simply remove the file from your working directory, it shows up under the “Changed but not updated” (that is, unstaged) area of your git status output:</p><p>$ rm PROJECTS.md</p><p>$ git status</p><p>On branch master</p><p>Your branch is up-to-date with 'origin/master'.</p><p>Changes not staged for commit:</p><p>  (use \"git add/rm <file>...\" to update what will be committed)</p>(use \"git checkout -- <file>...\" to discard changes in working directory)</p><p>        deleted:    PROJECTS.md</p><p>no changes added to commit (use \"git add\" and/or \"git commit -a\")</p><p>Then, if you run git rm, it stages the file’s removal:</p><p> $ git rm PROJECTS.md</p><p>rm 'PROJECTS.md'</p><p>$ git status</p><p>On branch master</p><p>Your branch is up-to-date with 'origin/master'.</p><p>Changes to be committed:</p><p>  (use \"git reset HEAD <file>...\" to unstage)</p><p>    deleted:    PROJECTS.md</p> <p> The next time you commit, the file will be gone and no longer tracked. If you modified the file and added it to the staging area already, you must force the removal with the -f option. This is a safety feature to prevent accidental removal of data that hasn’t yet been recorded in a snapshot and that can’t be recovered from Git.</p> <p> Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your .gitignore file and accidentally staged it, like a large log file or a bunch of .a compiled files. To do this, use the --cached option:</p><p>$ git rm --cached README </p> <p>You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as: </p> <p>$ git rm log/\\*.log</p> <p> Note the backslash (\\) in front of the *. This is necessary because Git does its own filename expansion in addition to your shell’s filename expansion. This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this:</p><p>$ git rm \\*~ </p> <p>This command removes all files whose names end with a ~. </p>"
    },
    {
      "title": "Moving Files",
      "body": "<p>Unlike many other VCS systems, Git doesn’t explicitly track file movement. If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file. However, Git is pretty smart about figuring that out after the fact — we’ll deal with detecting file movement a bit later.</p><p> Thus it’s a bit confusing that Git has a mv command. If you want to rename a file in Git, you can run something like:</p> <p>$ git mv file_from file_to</p> <p> and it works fine. In fact, if you run something like this and look at the status, you’ll see that Git considers it a renamed file:</p> <p> $ git mv README.md README</p><p>$ git status</p><p>On branch master</p><p>Your branch is up-to-date with 'origin/master'.</p><p>Changes to be committed:</p><p>(use \"git reset HEAD <file>...\" to unstage)</p><p>    renamed:    README.md -> README</p><p> However, this is equivalent to running something like this:</p> <p>$ mv README.md README</p><p>$ git rm README.md</p><p>$ git add README </p> <p> Git figures out that it’s a rename implicitly, so it doesn’t matter if you rename a file that way or with the mv command. The only real difference is that git mv is one command instead of three — it’s a convenience function. More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.</p>"
    },
    {
      "title": "Viewing the Commit History",
      "body": "<p>After you have created several commits, or if you have cloned a repository with an existing commit history, you’ll probably want to look back to see what has happened. The most basic and powerful tool to do this is the git log command. </p> <p> These examples use a very simple project called “simplegit”. To get the project, run</p> <p> $ git clone https://github.com/schacon/simplegit-progit</p> <p> When you run git log in this project, you should get output that looks something like this:</p> <p> $ git log</p><p>commit ca82a6dff817ec66f44342007202690a93763949</p><p>Author: Scott Chacon <schacon@gee-mail.com> </p><p> Date:   Mon Mar 17 21:52:11 2008 -0700 </p> <p>    changed the version number </p> <p>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</p><p>Author: Scott Chacon <schacon@gee-mail.com> </p><p>Date:   Sat Mar 15 16:40:33 2008 -0700</p><p>    removed unnecessary test </p> <p> commit a11bef06a3f659402fe7563abf99ad00de2209e6 </p><p>Author: Scott Chacon <schacon@gee-mail.com></p><p>Date:   Sat Mar 15 10:31:28 2008 -0700</p><p>    first commit</p> <p> By default, with no arguments, git log lists the commits made in that repository in reverse chronological order — that is, the most recent commits show up first. As you can see, this command lists each commit with its SHA-1 checksum, the author’s name and email, the date written, and the commit message.</p> "
    },
    {
      "title": "Git Log options",
      "body": "<p> A huge number and variety of options to the git log command are available to show you exactly what you’re looking for. Here, we’ll show you some of the most popular.</p> <p> One of the more helpful options is -p or --patch, which shows the difference (the patch output) introduced in each commit. You can also limit the number of log entries displayed, such as using -2 to show only the last two entries.</p> <p> $ git log -p -2</p><p>commit ca82a6dff817ec66f44342007202690a93763949 </p><p> Author: Scott Chacon <schacon@gee-mail.com></p><p> Date:   Mon Mar 17 21:52:11 2008 -0700 </p><p>    changed the version number</p><p> diff --git a/Rakefile b/Rakefile </p><p> index a874b73..8f94139 100644 </p><p> --- a/Rakefile </p><p> +++ b/Rakefile </p><p> @@ -5,7 +5,7 @@ require 'rake/gempackagetask'</p><p> spec = Gem::Specification.new do |s|</p><p>     s.platform  =   Gem::Platform::RUBY</p><p>     s.name      =   \"simplegit\"</p><p>-    s.version   =   \"0.1.0\"</p><p>+    s.version   =   \"0.1.1\" </p><p>     s.author    =   \"Scott Chacon\"</p><p>     s.email     =   \"schacon@gee-mail.com\" </p><p>     s.summary   =   \"A simple gem for using Git in Ruby code.\" </p><p>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</p><p> Author: Scott Chacon <schacon@gee-mail.com> </p><p> Date:   Sat Mar 15 16:40:33 2008 -0700 </p><p>    removed unnecessary test </p><p>diff --git a/lib/simplegit.rb b/lib/simplegit.rb </p><p>index a0a60ae..47c6340 100644 </p><p> --- a/lib/simplegit.rb </p><p> +++ b/lib/simplegit.rb </p><p>@@ -18,8 +18,3 @@ class SimpleGit</p><p>     end </p><p> end</p><p>- </p> <p> -if $0 == __FILE__ </p><p> -  git = SimpleGit.new </p><p> -  puts git.show </p><p> -end</p> <p> This option displays the same information but with a diff directly following each entry. This is very helpful for code review or to quickly browse what happened during a series of commits that a collaborator has added. You can also use a series of summarizing options with git log. For example, if you want to see some abbreviated stats for each commit, you can use the --stat option: </p> <p> $ git log --stat</p><p>commit ca82a6dff817ec66f44342007202690a93763949 </p><p>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</p><p>Date:   Mon Mar 17 21:52:11 2008 -0700</p><p>    changed the version number </p><p> Rakefile | 2 +- </p><p> 1 file changed, 1 insertion(+), 1 deletion(-) </p><p>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 </p><p>Author: Scott Chacon &lt;schacon@gee-mail.com&gt; </p><p> Date:   Sat Mar 15 16:40:33 2008 -0700 </p><p>    removed unnecessary test </p><p> lib/simplegit.rb | 5 ----- </p><p> 1 file changed, 5 deletions(-) </p><p> commit a11bef06a3f659402fe7563abf99ad00de2209e6 </p><p> Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</p><p>Date:   Sat Mar 15 10:31:28 2008 -0700 </p><p>    first commit </p><p> README           |  6 ++++++ </p><p> Rakefile         | 23 +++++++++++++++++++++++ </p><p> lib/simplegit.rb | 25 +++++++++++++++++++++++++ </p><p> 3 files changed, 54 insertions(+)</p><p>As you can see, the --stat option prints below each commit entry a list of modified files, how many files were changed, and how many lines in those files were added and removed. It also puts a summary of the information at the end. </p> <p> Another really useful option is --pretty. This option changes the log output to formats other than the default. A few prebuilt options are available for you to use. The oneline option prints each commit on a single line, which is useful if you’re looking at a lot of commits. In addition, the short, full, and fuller options show the output in roughly the same format but with less or more information, respectively:</p> <p> $ git log --pretty=oneline </p><p>ca82a6dff817ec66f44342007202690a93763949 changed the version number </p><p> 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test </p><p> a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</p> <p> The most interesting option is format, which allows you to specify your own log output format. This is especially useful when you’re generating output for machine parsing — because you specify the format explicitly, you know it won’t change with updates to Git: </p> <p> $ git log --pretty=format:\"%h - %an, %ar : %s\"</p><p> ca82a6d - Scott Chacon, 6 years ago : changed the version number </p><p> 085bb3b - Scott Chacon, 6 years ago : removed unnecessary test </p><p> a11bef0 - Scott Chacon, 6 years ago : first commit</p>"
    },
    {
      "title": "More Git log options",
      "body": "<p>The oneline and format options are particularly useful with another log option called --graph. This option adds a nice little ASCII graph showing your branch and merge history: </p> <p>$ git log --pretty=format:\"%h %s\" --graph </p><p>* 2d3acf9 ignore errors from SIGCHLD on trap </p><p>*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit</p><p>|\\</p><p>| * 420eac9 Added a method for getting the current branch.</p><p>* | 30e367c timeout code and tests</p><p>* | 5a09431 add timeout protection to grit</p><p>* | e1193f8 support for heads with slashes in them</p><p>|/ </p><p>* d6016bc require time for xmlschema </P><p>*  11d191e Merge branch 'defunkt' into local </p> <p>This type of output will become more interesting as we go through branching and merging in the chapter on branching.</p> <p>Those are only some simple output-formatting options to git log — there are many more.</p>"
    },
    {
      "title": "Limiting Log Output",
      "body": "<p>In addition to output-formatting options, git log takes a number of useful limiting options — that is, options that let you show only a subset of commits. You’ve seen one such option already — the -2 option, which displays only the last two commits. In fact, you can do -<n>, where n is any integer to show the last n commits. In reality, you’re unlikely to use that often, because Git by default pipes all output through a pager so you see only one page of log output at a time. </p> <p> However, the time-limiting options such as --since and --until are very useful. For example, this command gets the list of commits made in the last two weeks:</p> <p>$ git log --since=2.weeks </p> <p>This command works with lots of formats — you can specify a specific date like \"2008-01-15\", or a relative date such as \"2 years 1 day 3 minutes ago\". </p><p> You can also filter the list to commits that match some search criteria. The --author option allows you to filter on a specific author, and the --grep option lets you search for keywords in the commit messages.</p> <p>Another really helpful filter is the -S option (colloquially referred to as Git’s “pickaxe” option), which takes a string and shows only those commits that changed the number of occurrences of that string. For instance, if you wanted to find the last commit that added or removed a reference to a specific function, you could call: </p> <p>$ git log -S function_name </p> <p>The last really useful option to pass to git log as a filter is a path. If you specify a directory or file name, you can limit the log output to commits that introduced a change to those files. This is always the last option and is generally preceded by double dashes (--) to separate the paths from the options. </p> "
    }
  ]
}