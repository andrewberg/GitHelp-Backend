{
  "lesson": [
    {
      "title": "Viewing Your Staged and Unstaged Changes",
      "body": "If the git status command is too vague for you - you want to know exactly what you changed, not just which files were changed - you can use the git diff command. We'll cover git diff in more detail later, but you'll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed - the patch, as it were.\n  Let's say you edit and stage the README file again and then edit the CONTRIBUTING.md file without staging it. If you run your git status command, you once again see something like this:\n  $ git status \n  On branch master \n  Your branch is up-to-date with 'origin/master'. \n  Changes to be committed: \n   (use \"git reset HEAD <file>...\" to unstage) \n    modified:   README\n  Changes not staged for commit: \n  (use \"git add <file>...\" to update what will be committed) \n  (use \"git checkout -- <file>...\" to discard changes in working directory) \n   modified:   CONTRIBUTING.md\n "
    },
    {
      "title": "Changed but not yet Staged",
      "body": " To see what you've changed but not yet staged, type git diff with no other arguments: \n  $ git diff \n  That command compares what is in your working directory with what is in your staging area. The result tells you the changes you've made that you haven't yet staged. \n  If you want to see what you've staged that will go into your next commit, you can use git diff --staged. This command compares your staged changes to your last commit: \n  $ git diff --staged \n  diff --git a/README b/README \n  new file mode 100644 \n  index 0000000..03902a1 \n  --- /dev\null \n  +++ b/README \n  @@ -0,0 +1 @@ \n  +My Project \n  It's important to note that git diff by itself doesn't show all changes made since your last commit - only changes that are still unstaged. This can be confusing, because if you've staged all of your changes, git diff will give you no output.\n"
    },
    {
      "title": "Another example",
      "body": "For another example, if you stage the CONTRIBUTING.md file and then edit it, you can use git diff to see the changes in the file that are staged and the changes that are unstaged. If our environment looks like this: \n  $ git add CONTRIBUTING.md \n  $ echo '# test line' >> CONTRIBUTING.md \n  $ git status \n  On branch master \n  Your branch is up-to-date with 'origin/master'. \n Changes to be committed \n    (use \"git reset HEAD <file>...\" to unstage) \n  modified:   CONTRIBUTING.md \n  Changes not staged for commit: \n  (use \"git add <file>...\" to update what will be committed) \n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n  modified:   CONTRIBUTING.md \n  Now you can use git diff to see what is still unstaged: \n  $ git diff \n  diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md \n  index 643e24f..87f08c8 100644 \n  --- a/CONTRIBUTING.md \n  +++ b/CONTRIBUTING.md \n  @@ -119,3 +119,4 @@ at the \n   ## Starter Projects \n  See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).+# test line \n  and git diff --cached to see what you've staged so far (--staged and --cached are synonyms): \n  $ git diff --cached \n  diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md \n  index 8ebb991..643e24f 100644 \n  --- a/CONTRIBUTING.md \n  +++ b/CONTRIBUTING.md \n  @@ -65,7 +65,8 @@ branch directly, things can get messy. \n  Please include a nice description of your changes when you submit your PR; \n  if we have to read the whole diff to figure out why you're contributing \n   in the first place, you're less likely to get feedback and have your change \n  -merged in. \n  +merged in. Also, split your changes into comprehensive chunks if your patch is \n  +longer than a dozen lines. \n"
    },
    {
      "title": "Committing your changes",
      "body": "  Now that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged - any files you have created or modified that you haven't run git add on since you edited them - won't go into this commit. They will stay as modified files on your disk. In this case, let's say that the last time you ran git status, you saw that everything was staged, so you're ready to commit your changes. The simplest way to commit is to type git commit:\n  $ git commit \n  Doing so launches your editor of choice. (This is set by your shell's EDITOR environment variable - usually vim or emacs, although you can configure it with whatever you want using the git config --global core.editor command as you saw in Getting Started). \n   The editor displays the following text (this example is a Vim screen):\n  # Please enter the commit message for your changes. Lines starting \n  # with '#' will be ignored, and an empty message aborts the commit.\n # On branch master \n # Your branch is up-to-date with 'origin/master' \n #\n # Changes to be committed:\n #new file:   README\n # modified:CONTRIBUTING.md\n #\n ~\n ~\n ~\n \".git/COMMIT_EDITMSG\" 9L, 283C  \n  You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing. (For an even more explicit reminder of what you've modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.) When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out). \n   Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag, like this:\n   $ git commit -m \"Story 182: Fix benchmarks for speed\"[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README\n  Now you've created your first commit! You can see that the commit has given you some output about itself: which branch you committed to (master), what SHA-1 checksum the commit has (463dc4f), how many files were changed, and statistics about lines added and removed in the commit.\n   Remember that the commit records the snapshot you set up in your staging area. Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.\n"
    },
    {
      "title": "Skipping the Staging Area",
      "body": " Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow. If you want to skip the staging area, Git provides a simple shortcut. Adding the -a option to the git commit command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add part:\n  $ git status\n On branch master\n Your branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n     modified:   CONTRIBUTING.md\n no changes added to commit (use \"git add\" and/or \"git commit -a\")\n $ git commit -a -m 'added new benchmarks'\n [master 83e38c7] added new benchmarks\n  1 file changed, 5 insertions(+), 0 deletions(-)\n Notice how you don't have to run git add on the CONTRIBUTING.md file in this case before you commit. That's because the -a flag includes all changed files. This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes. \n"
    }
  ]
}
